<p>In this article, we&#39;re gonna be discussing how a compiler works using <code>gcc</code>(GNU Compiler Collection) and a &quot;Hello, World&quot; program written in <a href="https://en.wikipedia.org/wiki/C_(programming_language)">C</a>.</p>
<h2 id="summary">Summary</h2>
<ol>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#what-is-a-compiler">What is a compiler?</a></li>
<li><a href="#preprocessing">Preprocessing</a></li>
<li><a href="#compiling">Compiling</a></li>
<li><a href="#assembling">Assembling</a></li>
<li><a href="#linking">Linking</a></li>
<li><a href="#references">References</a></li>
</ol>
<h2 id="introduction">Introduction</h2>
<pre><code class="language-c">// simple_program.c

#include &lt;stdio.h&gt;

int main(){
    printf(&quot;Hello, world!\n&quot;);
    return 0;
}
</code></pre>
<p>First of all, every computer program starts as a text file such as the <code>simple_program.c</code> above. This text file contains characters (human characters), so we can write and understand code easily. </p>
<pre><code class="language-bash">$ xxd simple_program.c

00000000: 2369 6e63 6c75 6465 2022 7374 6469 6f2e  #include &quot;stdio.
00000010: 6822 0a0a 696e 7420 6d61 696e 2829 7b0a  h&quot;..int main(){.
00000020: 2020 2020 7072 696e 7466 2822 4865 6c6c      printf(&quot;Hell
00000030: 6f2c 2077 6f72 6c64 5c6e 2229 3b0a 2020  o, world\n&quot;);.  
00000040: 2020 7265 7475 726e 2030 3b0a 7d0a         return 0;.}.
</code></pre>
<p>Using <code>xxd</code> command in my <code>simple_program.c</code>, we can read the <a href="https://en.wikipedia.org/wiki/Hexadecimal">hexadecimal</a> representation of the source code. For example, in the first line, we have <code>2369</code>, <code>23</code> is in hexadecimal and <code>23</code> in decimal number system is <code>35</code> which is the <a href="https://en.wikipedia.org/wiki/ASCII">ASCII</a> code for <code>#</code>. This pattern is the same for every other character in this C program. This type of representation is great for us humans, so we can understand everything and write code.</p>
<p>However, the computer is not a human, it is a machine and machines just understand binary digits (0s and 1s). How do we &quot;translate&quot; or even compile the code above to something that the computer can read and execute? For that, we use a software called &quot;compiler&quot;.</p>
<h3 id="what-is-a-compiler">What is a compiler?</h3>
<p>A compiler is simply a software that translates code written in some programming language into another programming language. In our case, we want a compiler that translates our C code into a sequence of low-level machine instruction. In order to do that translation, we need to understand 4 major step: Preprocessing, Compiling, Assembling, Linking.</p>
<h3 id="preprocessing">Preprocessing</h3>
<p>In the processing phase, the compiler will read all the directives that begin with <code>#</code>. In our case, <code>#include &lt;stdio.h&gt;</code>, the goal is to read the directive <code>stdio.h</code> and insert all the content of <code>stdio.h</code> directly in our program. For example, when we use <code>printf()</code> to print our <code>Hello, world!</code>, the function <code>printf()</code> is stored in the <code>stdio.h</code>. That&#39;s why we need to include this directive, otherwise we could get an error in the compilation.</p>
<p>To get the output of the processing, you can run <code>gcc -E simple_program.c</code>.</p>
<h3 id="compiling">Compiling</h3>
<p>In the compiling phase, the compiler will get our preprocessed program and actually compile it to a low-level language called <a href="https://en.wikipedia.org/wiki/Assembly_language">Assembly</a>. </p>
<p>In order to get the assembly instructions, we could run the following command: <code>gcc -S simple_program.c</code> and this will generate a file called <code>simple_program.s</code> (<code>.s</code> is the extension for files with Assembly instructions).</p>
<h3 id="assembling">Assembling</h3>
<p>In the assemblying phase, the compiler will get the <code>simple_progra.s</code> file and use the assembler for building a file object <code>.o</code> (maybe <code>.exe</code> for Windows) which is a binary file with machine instruction.</p>
<h3 id="linking">Linking</h3>
<p>Linking is the final step of the compilation. In this phase, the compiler will link all object codes from multiple modules that we potentially have used in our program. For example, we used <code>printf()</code> from <code>stdio.h</code>. Now, the linker will put everything together in the binary file and make a single executable file which is our program. </p>
<p>To get our program, we can run <code>gcc simple_program.c</code>. The result is gonna be a file called <code>a.out</code> (if there is no errors in the <code>simple_program.c</code>, otherwise you will not get your binary).</p>
<p>Now you can execute the program.</p>
<pre><code class="language-bash">$ ./a.out
Hello, world!
</code></pre>
<p>Now everytime you make changes to your program, you need to run the compiler again in your source code, so the software can generate a new binary with the changes.</p>
<h2 id="references">References</h2>
<p><a href="https://en.wikipedia.org/wiki/Assembly_language">Assembly Language</a>
<a href="https://en.wikipedia.org/wiki/Compiler">Compiler</a>
<a href="https://en.wikipedia.org/wiki/C_(programming_language)">C programming language</a></p>
